# netduma_r3 — Home Assistant custom component for Netduma R3
#
# File layout (drop this whole folder into <config>/custom_components/netduma_r3)
# custom_components/netduma_r3/
#   __init__.py
#   manifest.json
#   config_flow.py
#   const.py
#   client.py
#   coordinator.py
#   sensor.py
#   device_tracker.py
#   strings.json
#   translations/en.json
#
# ─────────────────────────────────────────────────────────────────────────────
# file: custom_components/netduma_r3/__init__.py
from __future__ import annotations

from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.const import Platform
from .const import DOMAIN

PLATFORMS: list[Platform] = [Platform.SENSOR, Platform.DEVICE_TRACKER]

async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)
    return True

async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    return await hass.config_entries.async_unload_platforms(entry, PLATFORMS)

# ─────────────────────────────────────────────────────────────────────────────
# file: custom_components/netduma_r3/manifest.json
{
  "domain": "netduma_r3",
  "name": "Netduma R3",
  "version": "0.1.0",
  "documentation": "",
  "requirements": [],
  "codeowners": ["@you"],
  "config_flow": true,
  "iot_class": "local_polling"
}

# ─────────────────────────────────────────────────────────────────────────────
# file: custom_components/netduma_r3/const.py
from __future__ import annotations

DOMAIN = "netduma_r3"
DEFAULT_SCAN_INTERVAL = 20  # seconds for device presence
DEFAULT_TREE_INTERVAL = 20  # seconds for traffic trees
DEFAULT_SYS_INTERVAL = 90   # seconds for system info

APP_DEVICES = "com.netdumasoftware.devicemanager"
APP_QOS = "com.netdumasoftware.smartqos"
APP_SYS = "com.netdumasoftware.systeminfo"

# ─────────────────────────────────────────────────────────────────────────────
# file: custom_components/netduma_r3/client.py
from __future__ import annotations

import asyncio
import json
from typing import Any

import aiohttp

JSON = dict[str, Any]

class DumaOSClient:
    """Minimal JSON‑RPC client for DumaOS apps on the R3.

    Expected endpoints:
      https://<host>/apps/<app-id>/rpc/
    """

    def __init__(
        self,
        host: str,
        session: aiohttp.ClientSession,
        *,
        verify_ssl: bool = False,
        username: str | None = None,
        password: str | None = None,
    ) -> None:
        # Many R3 firmwares use a self‑signed cert on HTTPS
        self._base = f"https://{host}"
        self._session = session
        self._verify_ssl = verify_ssl
        self._username = username
        self._password = password
        self._id = 0
        self._headers = {"Content-Type": "application/json"}

    async def _rpc(self, app: str, method: str, params: list[Any] | None = None) -> Any:
        self._id += 1
        url = f"{self._base}/apps/{app}/rpc/"
        payload = {
            "jsonrpc": "2.0",
            "id": self._id,
            "clienttype": "web",
            "method": method,
            "params": params or [],
        }
        auth = None
        if self._username and self._password:
            auth = aiohttp.BasicAuth(self._username, self._password)
        async with self._session.post(
            url,
            data=json.dumps(payload),
            headers=self._headers,
            ssl=self._verify_ssl,
            auth=auth,
        ) as resp:
            if resp.status == 401:
                # If the router uses cookie login, add it later here
                raise aiohttp.ClientResponseError(resp.request_info, resp.history, status=401)
            resp.raise_for_status()
            data = await resp.json(content_type=None)
        if "error" in data:
            raise RuntimeError(f"RPC error {data['error']}")
        return data.get("result")

    # Devices
    async def get_all_devices(self) -> list[JSON]:
        return await self._rpc("com.netdumasoftware.devicemanager", "get_all_devices")

    async def get_valid_online_interfaces(self) -> list[JSON]:
        return await self._rpc("com.netdumasoftware.devicemanager", "get_valid_online_interfaces")

    async def get_dhcp_leases(self) -> list[JSON]:
        return await self._rpc("com.netdumasoftware.devicemanager", "get_dhcp_leases")

    # QoS trees
    async def get_upload_tree(self) -> dict:
        res = await self._rpc("com.netdumasoftware.smartqos", "get_upload_tree")
        return _parse_tree(res)

    async def get_download_tree(self) -> dict:
        res = await self._rpc("com.netdumasoftware.smartqos", "get_download_tree")
        return _parse_tree(res)

    async def get_throt_percentage(self) -> list[int]:
        return await self._rpc("com.netdumasoftware.smartqos", "get_throt_percentage")

    # System
    async def get_system_info(self) -> dict:
        res = await self._rpc("com.netdumasoftware.systeminfo", "get_system_info")
        # Some firmwares wrap single dict inside a list
        if isinstance(res, list) and res:
            return res[0]
        return res or {}


def _parse_tree(result_any: Any) -> dict:
    """smartqos returns a JSON string inside result; unwrap it."""
    # Expected shapes seen in HAR: ["{...json...}"] or "{...json...}"
    if isinstance(result_any, list) and result_any:
        inner = result_any[0]
    else:
        inner = result_any
    if isinstance(inner, str):
        try:
            return json.loads(inner)
        except json.JSONDecodeError:
            return {}
    if isinstance(inner, dict):
        return inner
    return {}

# ─────────────────────────────────────────────────────────────────────────────
# file: custom_components/netduma_r3/coordinator.py
from __future__ import annotations

import time
from collections import defaultdict
from typing import Any

from homeassistant.core import HomeAssistant
from homeassistant.helpers.update_coordinator import DataUpdateCoordinator
from homeassistant.helpers.aiohttp_client import async_get_clientsession

from .client import DumaOSClient
from .const import DEFAULT_SCAN_INTERVAL, DEFAULT_TREE_INTERVAL, DEFAULT_SYS_INTERVAL

class NetdumaDataCoordinator(DataUpdateCoordinator[dict[str, Any]]):
    def __init__(self, hass: HomeAssistant, entry) -> None:
        self.hass = hass
        self.entry = entry
        self.session = async_get_clientsession(hass)
        self.client = DumaOSClient(
            entry.data["host"],
            self.session,
            verify_ssl=entry.data.get("verify_ssl", False),
            username=entry.data.get("username"),
            password=entry.data.get("password"),
        )
        super().__init__(
            hass,
            logger=hass.logger,
            name="netduma_r3",
            update_interval=None,  # manual scheduling per‑task
        )
        # internal state
        self._last_bytes: dict[str, dict[str, int]] = defaultdict(lambda: {"rx": 0, "tx": 0})
        self._last_ts = 0.0

    async def async_config_entry_first_refresh(self) -> None:
        await self._refresh_full()
        # schedule periodic tasks
        self.async_set_update_error(None)
        self._schedule_tasks()

    def _schedule_tasks(self) -> None:
        self.hass.helpers.event.async_track_time_interval(
            self._refresh_presence,
            self.hass.helpers.event.dt.timedelta(seconds=DEFAULT_SCAN_INTERVAL),
        )
        self.hass.helpers.event.async_track_time_interval(
            self._refresh_trees,
            self.hass.helpers.event.dt.timedelta(seconds=DEFAULT_TREE_INTERVAL),
        )
        self.hass.helpers.event.async_track_time_interval(
            self._refresh_system,
            self.hass.helpers.event.dt.timedelta(seconds=DEFAULT_SYS_INTERVAL),
        )

    async def _refresh_full(self, *_):
        devices = await self.client.get_all_devices()
        online = await self.client.get_valid_online_interfaces()
        up = await self.client.get_upload_tree()
        down = await self.client.get_download_tree()
        sys = await self.client.get_system_info()
        self._merge_state(devices, online, up, down, sys)
        self.async_set_updated_data(self.data)

    async def _refresh_presence(self, *_):
        try:
            online = await self.client.get_valid_online_interfaces()
            self._merge_presence(online)
            self.async_set_updated_data(self.data)
        except Exception as err:  # keep running
            self.async_set_update_error(err)

    async def _refresh_trees(self, *_):
        try:
            up = await self.client.get_upload_tree()
            down = await self.client.get_download_tree()
            self._merge_traffic(up, down)
            self.async_set_updated_data(self.data)
        except Exception as err:
            self.async_set_update_error(err)

    async def _refresh_system(self, *_):
        try:
            sys = await self.client.get_system_info()
            self.data.setdefault("system", {}).update(sys or {})
            self.async_set_updated_data(self.data)
        except Exception as err:
            self.async_set_update_error(err)

    def _merge_state(self, devices, online, up, down, sys):
        self.data = {
            "devices": self._index_devices(devices or []),
            "presence": self._presence_map(online or []),
            "traffic": self._traffic_from_trees(up or {}, down or {}),
            "system": sys or {},
        }
        self._last_ts = time.time()
        # seed last bytes for delta
        for devid, t in self.data["traffic"].items():
            self._last_bytes[devid] = {"rx": t.get("rx_bytes", 0), "tx": t.get("tx_bytes", 0)}

    def _merge_presence(self, online):
        self.data.setdefault("presence", {}).update(self._presence_map(online or []))

    def _merge_traffic(self, up, down):
        now = time.time()
        dt = max(1.0, now - (self._last_ts or now))
        self._last_ts = now

        merged = self._traffic_from_trees(up or {}, down or {})
        for devid, t in merged.items():
            last = self._last_bytes[devid]
            rx, tx = t.get("rx_bytes", 0), t.get("tx_bytes", 0)
            t["rx_rate_bps"] = (rx - last.get("rx", 0)) / dt
            t["tx_rate_bps"] = (tx - last.get("tx", 0)) / dt
            self._last_bytes[devid] = {"rx": rx, "tx": tx}
        self.data.setdefault("traffic", {}).update(merged)

    def _index_devices(self, devices):
        out = {}
        for d in devices:
            devid = str(d.get("devid"))
            name = d.get("uhost") or d.get("hostname") or f"device_{devid}"
            # interfaces is a list of dicts with mac
            macs = [i.get("mac") for i in d.get("interfaces", []) if i.get("mac")]
            out[devid] = {"name": name, "macs": macs}
        return out

    def _presence_map(self, online):
        mac_online = {i.get("mac"): True for i in online if i.get("mac")}
        present = {}
        for devid, meta in self.data.get("devices", {}).items():
            present[devid] = any(mac_online.get(m) for m in meta.get("macs", []))
        return present

    def _traffic_from_trees(self, up_tree, down_tree):
        # Each tree has AutoAlloc.bandwidth_allocations with bytes and match.devid
        acc: dict[str, dict[str, int]] = {}
        for tree, key in [(down_tree, "rx_bytes"), (up_tree, "tx_bytes")]:
            try:
                ba = (
                    tree.get("AutoAlloc", {}).get("bandwidth_allocations")
                    or tree.get("AutoAlloc", {}).get("BandwidthAllocations")
                    or []
                )
                for item in ba:
                    devid = str(item.get("match", {}).get("devid"))
                    bytes_val = int(item.get("bytes", 0))
                    acc.setdefault(devid, {"rx_bytes": 0, "tx_bytes": 0})
                    acc[devid][key] += bytes_val
            except Exception:
                continue
        return acc

# ─────────────────────────────────────────────────────────────────────────────
# file: custom_components/netduma_r3/config_flow.py
from __future__ import annotations

from typing import Any
import voluptuous as vol

from homeassistant import config_entries
from homeassistant.core import HomeAssistant
from homeassistant.data_entry_flow import FlowResult

from .const import DOMAIN

class NetdumaConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
    VERSION = 1

    async def async_step_user(self, user_input: dict[str, Any] | None = None) -> FlowResult:
        errors: dict[str, str] = {}
        if user_input is not None:
            host = user_input["host"].strip()
            await self.async_set_unique_id(host)
            self._abort_if_unique_id_configured()
            return self.async_create_entry(title=f"Netduma R3 ({host})", data=user_input)

        schema = vol.Schema(
            {
                vol.Required("host"): str,  # e.g. 192.168.77.1
                vol.Optional("verify_ssl", default=False): bool,
                vol.Optional("username"): str,
                vol.Optional("password"): str,
            }
        )
        return self.async_show_form(step_id="user", data_schema=schema, errors=errors)

# ─────────────────────────────────────────────────────────────────────────────
# file: custom_components/netduma_r3/sensor.py
from __future__ import annotations

from typing import Any

from homeassistant.components.sensor import SensorEntity
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .coordinator import NetdumaDataCoordinator
from .const import DOMAIN

async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback) -> None:
    coordinator = NetdumaDataCoordinator(hass, entry)
    await coordinator.async_config_entry_first_refresh()

    entities: list[SensorEntity] = []

    # Router‑level sensors
    entities.append(RouterUptimeSensor(coordinator))
    entities.append(RouterFirmwareSensor(coordinator))

    # Per‑device traffic sensors
    for devid, meta in coordinator.data.get("devices", {}).items():
        name = meta.get("name", devid)
        entities.append(DeviceBytesSensor(coordinator, devid, name, "rx"))
        entities.append(DeviceBytesSensor(coordinator, devid, name, "tx"))
        entities.append(DeviceRateSensor(coordinator, devid, name, "rx"))
        entities.append(DeviceRateSensor(coordinator, devid, name, "tx"))

    async_add_entities(entities)

class BaseNetdumaSensor(CoordinatorEntity[NetdumaDataCoordinator], SensorEntity):
    _attr_has_entity_name = True

    def __init__(self, coordinator: NetdumaDataCoordinator) -> None:
        super().__init__(coordinator)

class RouterUptimeSensor(BaseNetdumaSensor):
    def __init__(self, coordinator: NetdumaDataCoordinator) -> None:
        super().__init__(coordinator)
        self._attr_name = "Router uptime"
        self._attr_unique_id = f"{coordinator.entry.data['host']}_uptime"
        self._attr_icon = "mdi:timer-outline"
        self._attr_native_unit_of_measurement = "s"

    @property
    def native_value(self) -> Any:
        return (self.coordinator.data.get("system", {}) or {}).get("uptime")

class RouterFirmwareSensor(BaseNetdumaSensor):
    def __init__(self, coordinator: NetdumaDataCoordinator) -> None:
        super().__init__(coordinator)
        self._attr_name = "Router firmware"
        self._attr_unique_id = f"{coordinator.entry.data['host']}_fw"
        self._attr_icon = "mdi:update"

    @property
    def native_value(self) -> Any:
        return (self.coordinator.data.get("system", {}) or {}).get("version")

class DeviceBytesSensor(BaseNetdumaSensor):
    def __init__(self, coordinator: NetdumaDataCoordinator, devid: str, name: str, dir_key: str) -> None:
        super().__init__(coordinator)
        self.devid = devid
        self.dir_key = dir_key  # "rx" or "tx"
        self._attr_name = f"{name} {dir_key.upper()} bytes"
        self._attr_unique_id = f"{coordinator.entry.data['host']}_{devid}_{dir_key}_bytes"
        self._attr_native_unit_of_measurement = "byte"
        self._attr_icon = "mdi:counter"

    @property
    def native_value(self) -> Any:
        t = self.coordinator.data.get("traffic", {}).get(self.devid, {})
        return t.get(f"{self.dir_key}_bytes")

class DeviceRateSensor(BaseNetdumaSensor):
    def __init__(self, coordinator: NetdumaDataCoordinator, devid: str, name: str, dir_key: str) -> None:
        super().__init__(coordinator)
        self.devid = devid
        self.dir_key = dir_key
        self._attr_name = f"{name} {dir_key.upper()} rate"
        self._attr_unique_id = f"{coordinator.entry.data['host']}_{devid}_{dir_key}_rate"
        self._attr_native_unit_of_measurement = "B/s"
        self._attr_icon = "mdi:swap-vertical"

    @property
    def native_value(self) -> Any:
        t = self.coordinator.data.get("traffic", {}).get(self.devid, {})
        return t.get(f"{self.dir_key}_rate_bps")

# ─────────────────────────────────────────────────────────────────────────────
# file: custom_components/netduma_r3/device_tracker.py
from __future__ import annotations

from homeassistant.components.device_tracker import DeviceTrackerEntity
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .coordinator import NetdumaDataCoordinator

async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback) -> None:
    coordinator = NetdumaDataCoordinator(hass, entry)
    await coordinator.async_config_entry_first_refresh()

    entities: list[DeviceTrackerEntity] = []
    for devid, meta in coordinator.data.get("devices", {}).items():
        name = meta.get("name", devid)
        entities.append(NetdumaTracker(coordinator, devid, name))
    async_add_entities(entities)

class NetdumaTracker(CoordinatorEntity[NetdumaDataCoordinator], DeviceTrackerEntity):
    _attr_has_entity_name = True

    def __init__(self, coordinator: NetdumaDataCoordinator, devid: str, name: str) -> None:
        super().__init__(coordinator)
        self.devid = devid
        self._attr_name = name
        self._attr_unique_id = f"{coordinator.entry.data['host']}_{devid}_presence"

    @property
    def is_connected(self) -> bool:
        return bool(self.coordinator.data.get("presence", {}).get(self.devid))

    @property
    def source_type(self):
        return "router"

# ─────────────────────────────────────────────────────────────────────────────
# file: custom_components/netduma_r3/strings.json
{
  "config": {
    "step": {
      "user": {
        "title": "Netduma R3",
        "description": "Enter connection settings",
        "data": {
          "host": "Host",
          "verify_ssl": "Verify SSL",
          "username": "Username",
          "password": "Password"
        }
      }
    }
  }
}

# ─────────────────────────────────────────────────────────────────────────────
# file: custom_components/netduma_r3/translations/en.json
{
  "config": {
    "step": {
      "user": {
        "title": "Netduma R3",
        "description": "Enter connection settings",
        "data": {
          "host": "Host",
          "verify_ssl": "Verify SSL",
          "username": "Username",
          "password": "Password"
        }
      }
    }
  }
}

# ─────────────────────────────────────────────────────────────────────────────
# Quick install
# 1) Create the folder: <config>/custom_components/netduma_r3
# 2) Copy files accordingly.
# 3) Restart Home Assistant.
# 4) Add Integration → Netduma R3 → enter host, toggle SSL verify off if self‑signed.
#
# Notes
# • If the router requires a cookie login instead of basic auth, add a small login method in client.py that mimics the web UI and stores the returned cookie in the ClientSession. The RPCs above usually work on LAN without extra headers.
# • Traffic rate is computed from QoS trees byte counters; it assumes monotonically increasing counters.
# • Entity explosion: you can filter which devices to expose by adding an include/exclude option in config_flow and checking it when creating entities.
